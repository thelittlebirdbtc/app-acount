{"version":3,"file":"index.js","mappings":"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","sources":["webpack://StacksNetwork/webpack/universalModuleDefinition","webpack://StacksNetwork/webpack/bootstrap","webpack://StacksNetwork/webpack/runtime/define property getters","webpack://StacksNetwork/webpack/runtime/hasOwnProperty shorthand","webpack://StacksNetwork/webpack/runtime/make namespace object","webpack://StacksNetwork/./src/constants.ts","webpack://StacksNetwork/../common/dist/esm/constants.js","webpack://StacksNetwork/../common/dist/esm/fetch.js","webpack://StacksNetwork/./src/network.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StacksNetwork\"] = factory();\n\telse\n\t\troot[\"StacksNetwork\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * The chain ID (unsigned 32-bit integer), used so transactions can't be replayed on other chains.\n * Similar to the {@link TransactionVersion}.\n */\nexport enum ChainId {\n  Mainnet = 0x00000001,\n  Testnet = 0x80000000,\n}\n\n/**\n * The **peer** network ID.\n * Typically not used in signing, but used for broadcasting to the P2P network.\n * It can also be used to determine the parent of a subnet.\n *\n * **Attention:**\n * For mainnet/testnet the v2/info response `.network_id` refers to the chain ID.\n * For subnets the v2/info response `.network_id` refers to the peer network ID and the chain ID (they are the same for subnets).\n * The `.parent_network_id` refers to the actual peer network ID (of the parent) in both cases.\n */\nexport enum PeerNetworkId {\n  Mainnet = 0x17000000,\n  Testnet = 0xff000000,\n}\n\nexport const DEFAULT_CHAIN_ID = ChainId.Mainnet;\n\n/**\n * The transaction version, used so transactions can't be replayed on other networks.\n * Similar to the {@link ChainId}.\n * Used internally for serializing and deserializing transactions.\n */\nexport enum TransactionVersion {\n  Mainnet = 0x00,\n  Testnet = 0x80,\n}\n\n/**\n * Address versions for identifying address types in an encoded Stacks address.\n * The address version is a single byte, indicating the address type.\n * Every Stacks address starts with `S` followed by a single character indicating the address version.\n * The second character is the c32-encoded AddressVersion byte.\n */\nexport enum AddressVersion {\n  /** `P` — A single-sig address for mainnet (starting with `SP`) */\n  MainnetSingleSig = 22,\n  /** `M` — A multi-sig address for mainnet (starting with `SM`) */\n  MainnetMultiSig = 20,\n  /** `T` — A single-sig address for testnet (starting with `ST`) */\n  TestnetSingleSig = 26,\n  /** `N` — A multi-sig address for testnet (starting with `SN`) */\n  TestnetMultiSig = 21,\n}\n\nexport const DEFAULT_TRANSACTION_VERSION = TransactionVersion.Mainnet;\n\n/** @ignore */\nexport function whenTransactionVersion(transactionVersion: TransactionVersion) {\n  return <T>(map: Record<TransactionVersion, T>): T => map[transactionVersion];\n}\n","export const HIRO_MAINNET_URL = 'https://api.mainnet.hiro.so';\nexport const HIRO_TESTNET_URL = 'https://api.testnet.hiro.so';\nexport const DEVNET_URL = 'http://localhost:3999';\nexport const GAIA_URL = 'https://hub.blockstack.org';\nexport const PRIVATE_KEY_BYTES_COMPRESSED = 33;\nexport const PRIVATE_KEY_BYTES_UNCOMPRESSED = 32;\n//# sourceMappingURL=constants.js.map","const defaultFetchOpts = {\n    referrerPolicy: 'origin',\n    headers: {\n        'x-hiro-product': 'stacksjs',\n    },\n};\nexport const getFetchOptions = () => {\n    return defaultFetchOpts;\n};\nexport const setFetchOptions = (ops) => {\n    return Object.assign(defaultFetchOpts, ops);\n};\nexport async function fetchWrapper(input, init) {\n    const fetchOpts = {};\n    Object.assign(fetchOpts, defaultFetchOpts, init);\n    const fetchResult = await fetch(input, fetchOpts);\n    return fetchResult;\n}\nexport function hostMatches(host, pattern) {\n    if (typeof pattern === 'string')\n        return pattern === host;\n    return pattern.exec(host);\n}\nexport function createApiKeyMiddleware({ apiKey, host = /(.*)api(.*)(\\.stacks\\.co|\\.hiro\\.so)$/i, httpHeader = 'x-api-key', }) {\n    return {\n        pre: context => {\n            const reqUrl = new URL(context.url);\n            if (!hostMatches(reqUrl.host, host))\n                return;\n            const headers = context.init.headers instanceof Headers\n                ? context.init.headers\n                : (context.init.headers = new Headers(context.init.headers));\n            headers.set(httpHeader, apiKey);\n        },\n    };\n}\nfunction argsForCreateFetchFn(args) {\n    let fetchLib = fetchWrapper;\n    let middlewares = [];\n    if (args.length > 0 && typeof args[0] === 'function') {\n        fetchLib = args.shift();\n    }\n    if (args.length > 0) {\n        middlewares = args;\n    }\n    return { fetchLib, middlewares };\n}\nexport function createFetchFn(...args) {\n    const { fetchLib, middlewares } = argsForCreateFetchFn(args);\n    const fetchFn = async (url, init) => {\n        let fetchParams = { url, init: init ?? {} };\n        for (const middleware of middlewares) {\n            if (typeof middleware.pre === 'function') {\n                const result = await Promise.resolve(middleware.pre({\n                    fetch: fetchLib,\n                    ...fetchParams,\n                }));\n                fetchParams = result ?? fetchParams;\n            }\n        }\n        let response = await fetchLib(fetchParams.url, fetchParams.init);\n        for (const middleware of middlewares) {\n            if (typeof middleware.post === 'function') {\n                const result = await Promise.resolve(middleware.post({\n                    fetch: fetchLib,\n                    url: fetchParams.url,\n                    init: fetchParams.init,\n                    response: response?.clone() ?? response,\n                }));\n                response = result ?? response;\n            }\n        }\n        return response;\n    };\n    return fetchFn;\n}\n//# sourceMappingURL=fetch.js.map","import {\n  ClientOpts,\n  DEVNET_URL,\n  FetchFn,\n  HIRO_MAINNET_URL,\n  HIRO_TESTNET_URL,\n  createFetchFn,\n} from '@stacks/common';\nimport { AddressVersion, ChainId, PeerNetworkId, TransactionVersion } from './constants';\nimport { ClientParam } from '@stacks/common';\n\nexport type StacksNetwork = {\n  chainId: number;\n  transactionVersion: number; // todo: txVersion better?\n  peerNetworkId: number;\n  magicBytes: string;\n  bootAddress: string;\n  addressVersion: {\n    singleSig: number;\n    multiSig: number;\n  };\n  // todo: add check32 character bytes string\n  client: {\n    baseUrl: string; // URL is always required\n    fetch?: FetchFn; // fetch is optional and will be created by default in fetch helpers\n  };\n};\n\nexport interface NetworkParam {\n  network?: StacksNetworkName | StacksNetwork;\n}\n\nexport type NetworkClientParam = NetworkParam & ClientParam;\n\nexport const STACKS_MAINNET: StacksNetwork = {\n  chainId: ChainId.Mainnet,\n  transactionVersion: TransactionVersion.Mainnet,\n  peerNetworkId: PeerNetworkId.Mainnet,\n  magicBytes: 'X2', // todo: comment bytes version of magic bytes\n  bootAddress: 'SP000000000000000000002Q6VF78',\n  addressVersion: {\n    singleSig: AddressVersion.MainnetSingleSig,\n    multiSig: AddressVersion.MainnetMultiSig,\n  },\n  client: { baseUrl: HIRO_MAINNET_URL },\n};\n\nexport const STACKS_TESTNET: StacksNetwork = {\n  chainId: ChainId.Testnet,\n  transactionVersion: TransactionVersion.Testnet,\n  peerNetworkId: PeerNetworkId.Testnet,\n  magicBytes: 'T2', // todo: comment bytes version of magic bytes\n  bootAddress: 'ST000000000000000000002AMW42H',\n  addressVersion: {\n    singleSig: AddressVersion.TestnetSingleSig,\n    multiSig: AddressVersion.TestnetMultiSig,\n  },\n  client: { baseUrl: HIRO_TESTNET_URL },\n};\n\nexport const STACKS_DEVNET: StacksNetwork = {\n  ...STACKS_TESTNET, // todo: ensure deep copy\n  addressVersion: { ...STACKS_TESTNET.addressVersion }, // deep copy\n  magicBytes: 'id', // todo: comment bytes version of magic bytes\n  client: { baseUrl: DEVNET_URL },\n};\n\nexport const STACKS_MOCKNET: StacksNetwork = {\n  ...STACKS_DEVNET,\n  addressVersion: { ...STACKS_DEVNET.addressVersion }, // deep copy\n  client: { ...STACKS_DEVNET.client }, // deep copy\n};\n\n/** @ignore internal */\nexport const StacksNetworks = ['mainnet', 'testnet', 'devnet', 'mocknet'] as const;\n/** The enum-style names of different common Stacks networks */\nexport type StacksNetworkName = (typeof StacksNetworks)[number];\n\n/**\n * Returns the default network for a given name\n * @example\n * ```ts\n * networkFromName('mainnet') // same as STACKS_MAINNET\n * networkFromName('testnet') // same as STACKS_TESTNET\n * networkFromName('devnet') // same as STACKS_DEVNET\n * networkFromName('mocknet') // same as STACKS_MOCKNET\n * ```\n */\nexport function networkFromName(name: StacksNetworkName) {\n  switch (name) {\n    case 'mainnet':\n      return STACKS_MAINNET;\n    case 'testnet':\n      return STACKS_TESTNET;\n    case 'devnet':\n      return STACKS_DEVNET;\n    case 'mocknet':\n      return STACKS_MOCKNET;\n    default:\n      throw new Error(`Unknown network name: ${name}`);\n  }\n}\n\n/** @ignore */\nexport function networkFrom(network: StacksNetworkName | StacksNetwork) {\n  if (typeof network === 'string') return networkFromName(network);\n  return network;\n}\n\n/** @ignore */\nexport function defaultUrlFromNetwork(network?: StacksNetworkName | StacksNetwork) {\n  if (!network) return HIRO_MAINNET_URL; // default to mainnet if no network is given\n\n  network = networkFrom(network);\n\n  return !network || network.transactionVersion === TransactionVersion.Mainnet\n    ? HIRO_MAINNET_URL // default to mainnet if txVersion is mainnet\n    : network.magicBytes === 'id'\n      ? DEVNET_URL // default to devnet if magicBytes are devnet\n      : HIRO_TESTNET_URL;\n}\n\n/**\n * Returns the client of a network, creating a new fetch function if none is available\n */\nexport function clientFromNetwork(network: StacksNetwork): Required<ClientOpts> {\n  if (network.client.fetch) return network.client as Required<ClientOpts>;\n  return {\n    ...network.client,\n    fetch: createFetchFn(),\n  };\n}\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","ChainId","PeerNetworkId","DEFAULT_CHAIN_ID","TransactionVersion","AddressVersion","DEFAULT_TRANSACTION_VERSION","whenTransactionVersion","transactionVersion","map","HIRO_MAINNET_URL","HIRO_TESTNET_URL","DEVNET_URL","defaultFetchOpts","referrerPolicy","headers","async","fetchWrapper","input","init","fetchOpts","assign","fetch","createFetchFn","args","fetchLib","middlewares","length","shift","argsForCreateFetchFn","url","fetchParams","middleware","pre","Promise","resolve","response","post","result","clone","STACKS_MAINNET","chainId","Mainnet","peerNetworkId","magicBytes","bootAddress","addressVersion","singleSig","MainnetSingleSig","multiSig","MainnetMultiSig","client","baseUrl","STACKS_TESTNET","Testnet","TestnetSingleSig","TestnetMultiSig","STACKS_DEVNET","STACKS_MOCKNET","StacksNetworks","networkFromName","name","Error","networkFrom","network","defaultUrlFromNetwork","clientFromNetwork"],"sourceRoot":""}